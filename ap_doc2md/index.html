
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Word (.docx) → Markdown Converter</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <!-- Your styles -->
  <link rel="stylesheet" href="styles.css">
  <link rel="stylesheet" href="../header.css">

  <!-- Libraries -->
  <script src="mammoth.browser.min.js" defer></script>
  <script src="turndown.js" defer></script>
  <script src="jszip.min.js" defer></script>

  <!-- Optional Markdown renderer (local); falls back to tiny inline renderer if absent -->
  <script src="marked.min.js" defer></script>

  <!-- Minimal styles for the file tree -->
  <style>
    .file-tree {
      max-height: 320px;
      overflow: auto;
      border: 1px solid #e5e5e5;
      padding: .5rem .75rem;
      border-radius: .375rem;
      background: #fff;
      font-size: 0.95rem;
    }
    .file-tree details { margin-left: .5rem; }
    .file-tree summary { cursor: pointer; user-select: none; }
    .file-tree .file-btn {
      background: none; border: 0; padding: 0 .15rem; margin: .1rem 0 .1rem 1.25rem;
      color: var(--link, #0b57d0); cursor: pointer; text-align: left; font: inherit;
    }
    .file-tree .file-btn:hover { text-decoration: underline; }
    .file-tree .muted { color: #888; }
    @media (prefers-color-scheme: dark) {
      .file-tree { border-color: #333; background: #181818; }
    }
  </style>
</head>
<body>
  <header>
    <div id="header"></div>
    <script>
      fetch('../header.html')
        .then(r => r.text())
        .then(html => { document.getElementById('header').innerHTML = html; });
    </script>
    <div class="meta">
      <h1>Word (.docx) → Markdown Converter</h1>
    </div>
  </header>

  <main>
    <!-- Existing DOCX conversion UI -->
    <section class="panel">
      <div class="dropzone" id="dropzone">
        <strong>Drop a .docx here</strong> or
        <label class="button" for="docxInput" id="chooseBtn">Choose file</label>
        <input id="docxInput" type="file" accept=".docx" />
        <div class="status" id="status">No file selected.</div>
      </div>
      <div class="controls" style="margin-top: .75rem;">
        <button id="convertBtn" disabled>Convert to Markdown</button>
        <button id="copyBtn" class="secondary" disabled>Copy Markdown</button>
        <button id="downloadMdBtn" class="secondary" disabled>Download .md</button>
        <button id="downloadAssetsBtn" class="secondary" disabled>Download images (zip)</button>
        <span class="muted">Options:</span>
        <label><input type="checkbox" id="smartQuotes" checked /> Smart punctuation → ASCII</label>
        <label><input type="checkbox" id="inlineImages" checked /> Inline images as base64</label>
      </div>
    </section>

    <section class="row">
      <div class="panel">
        <h2 style="margin-top:0;">Markdown</h2>
        <textarea id="mdOut" placeholder="Converted Markdown will appear here…" readonly></textarea>
      </div>
      <div class="panel">
        <h2 style="margin-top:0;">HTML preview (from Word or Markdown)</h2>
        <div id="htmlPreview" class="preview"></div>
      </div>
    </section>

    <section class="panel">
      <h2 style="margin-top:0;">Conversion details</h2>
      <div class="grid-3">
        <div><strong>HTML chars</strong><div><code class="kv" id="statsHtml">–</code></div></div>
        <div><strong>MD chars</strong><div><code class="kv" id="statsMd">–</code></div></div>
        <div><strong>Images</strong><div><code class="kv" id="statsImg">–</code></div></div>
      </div>
    </section>

    <!-- Hard-coded server directory listing -->
    <section class="panel">
      <h2 style="margin-top:0;">Server Markdown files</h2>
      <div class="muted" style="margin-bottom:.5rem;">
        Files are listed from a hard-coded server directory.
      </div>
      <div id="fileTree" class="file-tree" aria-live="polite"></div>
    </section>
  </main>

  <!-- App code -->
  <script>
    window.addEventListener('DOMContentLoaded', () => {
      // ---- Config: set your server path here ----
      // Example: const MD_BASE_PATH = '/docs';  // served by your Linux web server
      const MD_BASE_PATH = '/home/mantri/APSA/ap_architecture_docs_as_code';

      // Existing nodes
      const input = document.getElementById('docxInput');
      const dropzone = document.getElementById('dropzone');
      const convertBtn = document.getElementById('convertBtn');
      const copyBtn = document.getElementById('copyBtn');
      const downloadMdBtn = document.getElementById('downloadMdBtn');
      const downloadAssetsBtn = document.getElementById('downloadAssetsBtn');

      const status = document.getElementById('status');
      const mdOut = document.getElementById('mdOut');
      const htmlPreview = document.getElementById('htmlPreview');
      const statsHtml = document.getElementById('statsHtml');
      const statsMd = document.getElementById('statsMd');
      const statsImg = document.getElementById('statsImg');

      const inlineImagesCheckbox = document.getElementById('inlineImages');
      const smartQuotesCheckbox = document.getElementById('smartQuotes');

      let arrayBuffer = null;
      let imagesCollected = []; // {filename, dataUrl}
      let currentMd = '';

      // --- Drag & drop UX ---
      ['dragenter','dragover'].forEach(evt =>
        dropzone.addEventListener(evt, e => { e.preventDefault(); e.stopPropagation(); dropzone.classList.add('drag'); })
      );
      ['dragleave','drop'].forEach(evt =>
        dropzone.addEventListener(evt, e => { e.preventDefault(); e.stopPropagation(); dropzone.classList.remove('drag'); })
      );
      dropzone.addEventListener('drop', async e => {
        const file = e.dataTransfer.files?.[0];
        if (file) await handleFile(file);
      });

      document.getElementById('chooseBtn').addEventListener('click', (e) => {
        e.stopPropagation();
      });

      input.addEventListener('change', async (e) => {
        const file = e.target.files?.[0];
        if (file) await handleFile(file);
      });

      async function handleFile(file) {
        if (!file.name.toLowerCase().endsWith('.docx')) {
          status.textContent = 'Please select a .docx file.';
          return;
        }
        status.textContent = `Selected: ${file.name} (${(file.size/1024).toFixed(1)} KB)`;
        arrayBuffer = await file.arrayBuffer();
        convertBtn.disabled = false;
        copyBtn.disabled = true;
        downloadMdBtn.disabled = true;
        downloadAssetsBtn.disabled = true;
        mdOut.value = '';
        htmlPreview.innerHTML = '';
        statsHtml.textContent = '–';
        statsMd.textContent = '–';
        statsImg.textContent = '–';
        imagesCollected = [];
        currentMd = '';
      }

      // --- DOCX -> HTML -> Markdown ---
      convertBtn.addEventListener('click', async () => {
        if (!arrayBuffer) return;

        const inlineImages = inlineImagesCheckbox.checked;
        imagesCollected = [];
        const imageCallback = inlineImages
          ? mammoth.images.inline(function(element) {
              return element.read('base64').then(function(imageBuffer) {
                const mime = element.contentType || 'image/png';
                const dataUrl = `data:${mime};base64,${imageBuffer}`;
                const name = element.altText || `image-${imagesCollected.length + 1}`;
                imagesCollected.push({ filename: `${name}.${mime.split('/')[1] || 'png'}`, dataUrl });
                return { src: dataUrl };
              });
            })
          : mammoth.images.imgElement(function(element) {
              const name = element.altText || `image-${imagesCollected.length + 1}`;
              const ext = (element.contentType || 'image/png').split('/')[1] || 'png';
              return element.read('base64').then(function(imageBuffer) {
                const dataUrl = `data:${element.contentType};base64,${imageBuffer}`;
                imagesCollected.push({ filename: `${name}.${ext}`, dataUrl });
                return { src: `assets/${name}.${ext}` };
              });
            });

        try {
          status.textContent = 'Converting with Mammoth…';
          const mammothResult = await mammoth.convertToHtml({ arrayBuffer }, {
            styleMap: [
              "p[style-name='Title'] => h1.f-title",
              "p[style-name='Subtitle'] => h2.f-subtitle",
              "p[style-name='Heading 1'] => h1",
              "p[style-name='Heading 2'] => h2",
              "p[style-name='Heading 3'] => h3"
            ],
            convertImage: imageCallback
          });

          let html = mammothResult.value || '';
          const warnings = mammothResult.messages || [];

          if (smartQuotesCheckbox.checked) {
            html = html
              .replace(/[“”]/g, '"')
              .replace(/[‘’]/g, "'")
              .replace(/—/g, '--')
              .replace(/–/g, '-');
          }

          htmlPreview.innerHTML = html;
          statsHtml.textContent = String(html.length);

          status.textContent = 'Converting HTML to Markdown…';

          const td = new TurndownService({
            headingStyle: 'atx',
            hr: '---',
            codeBlockStyle: 'fenced',
            bulletListMarker: '-',
            emDelimiter: '*',
            strongDelimiter: '**'
          });

          td.addRule('unwrapEmptyLinks', {
            filter: node => node.nodeName === 'A' && !node.textContent.trim(),
            replacement: (content, node) => node.getAttribute('href') || ''
          });

          td.addRule('figureCaption', {
            filter: node => node.nodeName === 'FIGCAPTION',
            replacement: content => content ? `\n\n*${content}*\n\n` : '\n\n'
          });

          const markdown = td.turndown(html);
          mdOut.value = markdown;
          currentMd = markdown;

          statsMd.textContent = String(markdown.length);
          statsImg.textContent = String(imagesCollected.length);

          copyBtn.disabled = false;
          downloadMdBtn.disabled = false;
          downloadAssetsBtn.disabled = imagesCollected.length === 0 || inlineImages;
          status.textContent = warnings.length ? `Done with ${warnings.length} warning(s).` : 'Done.';
        } catch (err) {
          console.error(err);
          status.textContent = 'Conversion failed. See console for details.';
        }
      });

      // Copy Markdown
      copyBtn.addEventListener('click', async () => {
        try {
          await navigator.clipboard.writeText(mdOut.value);
          copyBtn.textContent = 'Copied!';
          setTimeout(() => (copyBtn.textContent = 'Copy Markdown'), 1200);
        } catch {
          mdOut.select();
          document.execCommand('copy');
        }
      });

      // Download .md
      downloadMdBtn.addEventListener('click', () => {
        const blob = new Blob([mdOut.value], { type: 'text/markdown;charset=utf-8' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'document.md';
        a.click();
        URL.revokeObjectURL(a.href);
      });

      // Download images as zip (only when not inlined)
      downloadAssetsBtn.addEventListener('click', async () => {
        const zip = new JSZip();
        const folder = zip.folder('assets');
        for (const img of imagesCollected) {
          const base64 = img.dataUrl.split(',')[1];
          folder.file(img.filename, base64, { base64: true });
        }
        const blob = await zip.generateAsync({ type: 'blob' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'assets.zip';
        a.click();
        URL.revokeObjectURL(a.href);
      });

      // --------------------------------------------------------------------------------
      // Hard-coded server directory listing for Markdown files
      // --------------------------------------------------------------------------------
      const fileTreeEl = document.getElementById('fileTree');

      // Build the listing now
      buildServerListing(MD_BASE_PATH)
        .then(tree => renderTree(tree, fileTreeEl))
        .catch(err => {
          console.error(err);
          fileTreeEl.innerHTML = '<div class="muted">Could not load server listing.</div>';
        });

      /**
       * Try to load MD file names from:
       *  1) JSON manifest: <MD_BASE_PATH>/index.json
       *  2) Autoindex HTML: <MD_BASE_PATH>/ (parse <a> links ending .md)
       * Returns a directory tree {name, kind, children, path}
       */
      async function buildServerListing(basePath) {
        const jsonUrl = normalizePath(basePath, 'index.json');
        const htmlUrl = normalizePath(basePath, '');
        let files = null;

        // Attempt JSON first
        try {
          const res = await fetch(jsonUrl, { cache: 'no-store' });
          if (res.ok) {
            const list = await res.json();
            files = Array.isArray(list) ? list.filter(isMdFile) : null;
          }
        } catch (_) { /* ignore */ }

        // Fallback: parse autoindex HTML
        if (!files) {
          const res = await fetch(htmlUrl, { cache: 'no-store' });
          if (res.ok) {
            const htmlText = await res.text();
            files = parseAutoindexForMdLinks(htmlText, basePath);
          }
        }

        if (!files || files.length === 0) {
          throw new Error('No Markdown files found at ' + basePath);
        }

        // Build a tree based on relative paths in the manifest/links
        const root = { name: trimSlashes(basePath) || '/', kind: 'directory', children: [], path: '' };
        const dirMap = new Map();
        dirMap.set('', root);

        for (const rel of files) {
          const cleanRel = rel.replace(/^\//, ''); // make relative
          const parts = cleanRel.split('/');
          let accPath = '';
          for (let i = 0; i < parts.length - 1; i++) {
            const p = parts[i];
            const next = accPath ? `${accPath}/${p}` : p;
            if (!dirMap.has(next)) {
              const parent = dirMap.get(accPath);
              const dirNode = { name: p, kind: 'directory', children: [], path: next };
              parent.children.push(dirNode);
              dirMap.set(next, dirNode);
            }
            accPath = next;
          }
          const parent = dirMap.get(accPath);
          const fileUrl = normalizePath(basePath, cleanRel);
          parent.children.push({ name: parts[parts.length - 1], kind: 'file', path: fileUrl });
        }

        sortTree(root);
        return root;
      }

      function isMdFile(s) { return /\.md$/i.test(s); }
      function trimSlashes(s) { return (s || '').replace(/^\/+|\/+$/g, ''); }
      function normalizePath(base, rel) {
        const b = trimSlashes(base);
        const r = trimSlashes(rel);
        if (!r) return `/${b}/`;
        return `/${b}/${r}`;
      }

      function parseAutoindexForMdLinks(htmlText, basePath) {
        const container = document.createElement('div');
        container.innerHTML = htmlText;
        const anchors = Array.from(container.querySelectorAll('a[href]'));
        const files = anchors
          .map(a => a.getAttribute('href'))
          .filter(href => href && isMdFile(href))
          .map(href => href.replace(/^\//, '')) // relative name
        ;
        return files;
      }

      function renderTree(node, container) {
        container.innerHTML = '';
        const treeEl = document.createElement('div');
        treeEl.appendChild(renderNode(node));
        container.appendChild(treeEl);
      }

      function renderNode(node) {
        if (node.kind === 'file') {
          const btn = document.createElement('button');
          btn.className = 'file-btn';
          btn.type = 'button';
          btn.textContent = node.name;
          btn.title = node.path;
          btn.addEventListener('click', () => loadServerMarkdown(node.path));
          return btn;
        } else {
          const details = document.createElement('details');
          details.open = true;
          const summary = document.createElement('summary');
          summary.textContent = node.name;
          details.appendChild(summary);
          for (const child of node.children) {
            const childEl = renderNode(child);
            const wrapper = document.createElement('div');
            wrapper.appendChild(childEl);
            details.appendChild(wrapper);
          }
          return details;
        }
      }

      function sortTree(node) {
        if (!node.children) return;
        node.children.sort((a, b) => {
          if (a.kind !== b.kind) return a.kind === 'directory' ? -1 : 1;
          return a.name.localeCompare(b.name, undefined, { sensitivity: 'base' });
        });
        for (const c of node.children) if (c.kind === 'directory') sortTree(c);
      }

      // Load a server-side Markdown file via HTTP and preview it
      async function loadServerMarkdown(url) {
        try {
          status.textContent = `Loading ${url}…`;
          const res = await fetch(url, { cache: 'no-store' });
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const md = await res.text();

          mdOut.readOnly = false;
          mdOut.value = md;
          statsMd.textContent = String(md.length);

          const html = renderMarkdownToHtml(md);
          htmlPreview.innerHTML = html;
          statsHtml.textContent = String(html.length);

          statsImg.textContent = '–';
          copyBtn.disabled = false;
          downloadMdBtn.disabled = false;
          downloadAssetsBtn.disabled = true;

          status.textContent = `Loaded: ${url}`;
          htmlPreview.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
        } catch (e) {
          console.error(e);
          status.textContent = `Failed to load ${url}.`;
        }
      }

      // Markdown renderer shim
      function renderMarkdownToHtml(md) {
        if (window.marked && typeof window.marked.parse === 'function') {
          return window.marked.parse(md, { mangle: false, headerIds: true });
        }
        // Tiny fallback (safe-ish): escape + simple rules
        let safe = md
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;');

        // headings
        safe = safe.replace(/^(#{1,6})\s*(.+)$/gm, (_, h, t) => `<h${h.length}>${t}</h${h.length}>`);
        // hr
        safe = safe.replace(/^\s*[-*_]{3,}\s*$/gm, '<hr>');
        // bold/italic
        safe = safe.replace(/\*\*([\s\S]+?)\*\*/g, '<strong>$1</strong>');
        safe = safe.replace(/\*([\s\S]+?)\*/g, '<em>$1</em>');
        // fences
        safe = safe.replace(/```([\s\S]*?)```/g, '<pre><code>$1</code></pre>');
        // inline code
        safe = safe.replace(/`([^`]+)`/g, '<code>$1</code>');
        // links [text](href "title")
        safe = safe.replace(/\[([^\]]+)\]\(([^)\s]+)(?:\s+"[^"]*")?\)/g,
          (_m, text, href) => `${href}${text}</a>`);
        // unordered lists (basic)
        safe = safe.replace(/^(?:\s*[-*+]\s+.+(?:\n|$))+?/gm, block => {
          const items = block.trim().split(/\n/).map(line =>
            line.replace(/^\s*[-*+]\s+(.+)$/, '<li>$1</li>')
          ).join('');
          return `<ul>${items}</ul>`;
        });
        // paragraphs
        const isBlock = /^(<h\d|<pre|<hr|<ul|<ol|<blockquote)/;
        safe = safe.split(/\n{2,}/).map(chunk => {
          if (isBlock.test(chunk)) return chunk;
          const c = chunk.replace(/\n/g, '<br>');
          return c.trim() ? `<p>${c}</p>` : '';
        }).join('');

        return safe;
      }
    });
  </script>
</body>
</html>