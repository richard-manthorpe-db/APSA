
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Word (.docx) → Markdown Converter</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <!-- Your styles -->
  <link rel="stylesheet" href="styles.css" />
  <link rel="stylesheet" href="../header.css" />

  <!-- Libraries (load first) -->
  <script src="mammoth.browser.min.js" defer></script>
  <script src="turndown.js" defer></script>
  <script src="jszip.min.js" defer></script>

  <!-- Markdown renderer (optional, local; falls back to tiny inline renderer if absent) -->
  <script src="marked.min.js" defer></script>

  <!-- Minimal styles for the file tree and small UX helpers -->
  <style>
    .file-tree {
      max-height: 320px;
      overflow: auto;
      border: 1px solid #e5e5e5;
      padding: .5rem .75rem;
      border-radius: .375rem;
      background: #fff;
      font-size: 0.95rem;
    }
    .file-tree details { margin-left: .5rem; }
    .file-tree summary { cursor: pointer; user-select: none; }
    .file-tree .file-btn {
      background: none; border: 0; padding: 0 .15rem; margin: .1rem 0 .1rem 1.25rem;
      color: var(--link, #0b57d0); cursor: pointer; text-align: left; font: inherit;
    }
    .file-tree .file-btn:hover { text-decoration: underline; }
    .file-tree .muted { color: #888; }
    .linklike { background: none; border: 0; color: var(--link, #0b57d0); cursor: pointer; padding: 0; }
    @media (prefers-color-scheme: dark) {
      .file-tree { border-color: #333; background: #181818; }
    }
  </style>
</head>
<body>
  <header>
    <div id="header"></div>
    <script>
      fetch('../header.html')
        .then(r => r.text())
        .then(html => { document.getElementById('header').innerHTML = html; });
    </script>
    <div class="meta">
      <h1>Word (.docx) → Markdown Converter</h1>
    </div>
  </header>

  <main>
    <section class="panel">
      <div class="dropzone" id="dropzone">
        <strong>Drop a .docx here</strong> or
        <label class="button" for="docxInput" id="chooseBtn">Choose file</label>
        <input id="docxInput" type="file" accept=".docx" />
        <div class="status" id="status">No file selected.</div>
        <div class="muted" id="reopenHint" style="display:none;">
          Permission lost. <button id="reopenBtn" class="linklike">Reopen folder</button>
          or use the fallback <label for="folderInput" class="linklike">Pick a folder</label>.
        </div>
      </div>
      <div class="controls" style="margin-top: .75rem;">
        <button id="convertBtn" disabled>Convert to Markdown</button>
        <button id="copyBtn" class="secondary" disabled>Copy Markdown</button>
        <button id="downloadMdBtn" class="secondary" disabled>Download .md</button>
        <button id="downloadAssetsBtn" class="secondary" disabled>Download images (zip)</button>
        <span class="muted">Options:</span>
        <label><input type="checkbox" id="smartQuotes" checked /> Smart punctuation → ASCII</label>
        <label><input type="checkbox" id="inlineImages" checked /> Inline images as base64</label>
      </div>
    </section>

    <section class="row">
      <div class="panel">
        <h2 style="margin-top:0;">Markdown</h2>
        <textarea id="mdOut" placeholder="Converted Markdown will appear here…" readonly></textarea>
      </div>
      <div class="panel">
        <h2 style="margin-top:0;">HTML preview (from Word or Markdown)</h2>
        <div id="htmlPreview" class="preview"></div>
      </div>
    </section>

    <section class="panel">
      <h2 style="margin-top:0;">Conversion details</h2>
      <div class="grid-3">
        <div><strong>HTML chars</strong><div><code class="kv" id="statsHtml">–</code></div></div>
        <div><strong>MD chars</strong><div><code class="kv" id="statsMd">–</code></div></div>
        <div><strong>Images</strong><div><code class="kv" id="statsImg">–</code></div></div>
      </div>
    </section>

    <!-- Folder browser and directory tree for Markdown preview -->
    <section class="panel">
      <h2 style="margin-top:0;">Browse a folder of Markdown files</h2>
      <div class="controls" style="margin-bottom:.5rem;">
        <button id="openFolderBtn">Choose folder</button>
        <label class="button secondary" for="folderInput">Or pick a folder</label>
        <input id="folderInput" type="file" webkitdirectory directory multiple accept=".md" hidden />
        <span class="muted">Click an <code>.md</code> file below to preview it on the right.</span>
      </div>
      <div id="fileTree" class="file-tree" aria-live="polite"></div>
      <div class="muted" style="margin-top:.5rem;">
        Tip: “Choose folder” uses the File System Access API (best in Chromium browsers).
        “Pick a folder” works as a fallback in most modern browsers.
      </div>
    </section>
  </main>

  <!-- App code -->
  <script>
    window.addEventListener('DOMContentLoaded', () => {
      const input = document.getElementById('docxInput');
      const dropzone = document.getElementById('dropzone');
      const convertBtn = document.getElementById('convertBtn');
      const copyBtn = document.getElementById('copyBtn');
      const downloadMdBtn = document.getElementById('downloadMdBtn');
      const downloadAssetsBtn = document.getElementById('downloadAssetsBtn');

      const status = document.getElementById('status');
      const reopenHint = document.getElementById('reopenHint');
      const reopenBtn = document.getElementById('reopenBtn');

      const mdOut = document.getElementById('mdOut');
      const htmlPreview = document.getElementById('htmlPreview');
      const statsHtml = document.getElementById('statsHtml');
      const statsMd = document.getElementById('statsMd');
      const statsImg = document.getElementById('statsImg');

      const inlineImagesCheckbox = document.getElementById('inlineImages');
      const smartQuotesCheckbox = document.getElementById('smartQuotes');

      let arrayBuffer = null;
      let imagesCollected = []; // {filename, dataUrl}
      let currentMd = '';

      // Drag & drop UX
      ['dragenter','dragover'].forEach(evt =>
        dropzone.addEventListener(evt, e => { e.preventDefault(); e.stopPropagation(); dropzone.classList.add('drag'); })
      );
      ['dragleave','drop'].forEach(evt =>
        dropzone.addEventListener(evt, e => { e.preventDefault(); e.stopPropagation(); dropzone.classList.remove('drag'); })
      );
      dropzone.addEventListener('drop', async e => {
        const file = e.dataTransfer.files?.[0];
        if (file) await handleFile(file);
      });

      document.getElementById('chooseBtn').addEventListener('click', (e) => {
        e.stopPropagation();
      });

      input.addEventListener('change', async (e) => {
        const file = e.target.files?.[0];
        if (file) await handleFile(file);
      });

      async function handleFile(file) {
        if (!file.name.toLowerCase().endsWith('.docx')) {
          status.textContent = 'Please select a .docx file.';
          return;
        }
        status.textContent = `Selected: ${file.name} (${(file.size/1024).toFixed(1)} KB)`;
        arrayBuffer = await file.arrayBuffer();
        convertBtn.disabled = false;
        copyBtn.disabled = true;
        downloadMdBtn.disabled = true;
        downloadAssetsBtn.disabled = true;
        mdOut.value = '';
        htmlPreview.innerHTML = '';
        statsHtml.textContent = '–';
        statsMd.textContent = '–';
        statsImg.textContent = '–';
        imagesCollected = [];
        currentMd = '';
      }

      // Convert flow: DOCX -> HTML (Mammoth) -> Markdown (TurndownService)
      convertBtn.addEventListener('click', async () => {
        if (!arrayBuffer) return;

        const inlineImages = inlineImagesCheckbox.checked;
        imagesCollected = [];
        const imageCallback = inlineImages
          ? mammoth.images.inline(function(element) {
              return element.read('base64').then(function(imageBuffer) {
                const mime = element.contentType || 'image/png';
                const dataUrl = `data:${mime};base64,${imageBuffer}`;
                const name = element.altText || `image-${imagesCollected.length + 1}`;
                imagesCollected.push({ filename: `${name}.${mime.split('/')[1] || 'png'}`, dataUrl });
                return { src: dataUrl };
              });
            })
          : mammoth.images.imgElement(function(element) {
              const name = element.altText || `image-${imagesCollected.length + 1}`;
              const ext = (element.contentType || 'image/png').split('/')[1] || 'png';
              return element.read('base64').then(function(imageBuffer) {
                const dataUrl = `data:${element.contentType};base64,${imageBuffer}`;
                imagesCollected.push({ filename: `${name}.${ext}`, dataUrl });
                return { src: `assets/${name}.${ext}` };
              });
            });

        try {
          status.textContent = 'Converting with Mammoth…';
          const mammothResult = await mammoth.convertToHtml({ arrayBuffer }, {
            styleMap: [
              "p[style-name='Title'] => h1.f-title",
              "p[style-name='Subtitle'] => h2.f-subtitle",
              "p[style-name='Heading 1'] => h1",
              "p[style-name='Heading 2'] => h2",
              "p[style-name='Heading 3'] => h3"
            ],
            convertImage: imageCallback
          });

          let html = mammothResult.value || '';
          const warnings = mammothResult.messages || [];

          if (smartQuotesCheckbox.checked) {
            html = html
              .replace(/[“”]/g, '"')
              .replace(/[‘’]/g, "'")
              .replace(/—/g, '--')
              .replace(/–/g, '-');
          }

          htmlPreview.innerHTML = html;
          statsHtml.textContent = String(html.length);

          status.textContent = 'Converting HTML to Markdown…';

          const td = new TurndownService({
            headingStyle: 'atx',
            hr: '---',
            codeBlockStyle: 'fenced',
            bulletListMarker: '-',
            emDelimiter: '*',
            strongDelimiter: '**'
          });

          td.addRule('unwrapEmptyLinks', {
            filter: node => node.nodeName === 'A' && !node.textContent.trim(),
            replacement: (content, node) => node.getAttribute('href') || ''
          });

          td.addRule('figureCaption', {
            filter: node => node.nodeName === 'FIGCAPTION',
            replacement: content => content ? `\n\n*${content}*\n\n` : '\n\n'
          });

          const markdown = td.turndown(html);
          mdOut.value = markdown;
          currentMd = markdown;

          statsMd.textContent = String(markdown.length);
          statsImg.textContent = String(imagesCollected.length);

          copyBtn.disabled = false;
          downloadMdBtn.disabled = false;
          downloadAssetsBtn.disabled = imagesCollected.length === 0 || inlineImages;
          status.textContent = warnings.length ? `Done with ${warnings.length} warning(s).` : 'Done.';
        } catch (err) {
          console.error(err);
          status.textContent = 'Conversion failed. See console for details.';
        }
      });

      // Copy Markdown
      copyBtn.addEventListener('click', async () => {
        try {
          await navigator.clipboard.writeText(mdOut.value);
          copyBtn.textContent = 'Copied!';
          setTimeout(() => (copyBtn.textContent = 'Copy Markdown'), 1200);
        } catch {
          mdOut.select();
          document.execCommand('copy');
        }
      });

      // Download .md
      downloadMdBtn.addEventListener('click', () => {
        const blob = new Blob([mdOut.value], { type: 'text/markdown;charset=utf-8' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'document.md';
        a.click();
        URL.revokeObjectURL(a.href);
      });

      // Download images as zip (only when not inlined)
      downloadAssetsBtn.addEventListener('click', async () => {
        const zip = new JSZip();
        const folder = zip.folder('assets');
        for (const img of imagesCollected) {
          const base64 = img.dataUrl.split(',')[1];
          folder.file(img.filename, base64, { base64: true });
        }
        const blob = await zip.generateAsync({ type: 'blob' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'assets.zip';
        a.click();
        URL.revokeObjectURL(a.href);
      });

      // ------------------ Directory tree for Markdown files (+ permission handling) ------------------
      const openFolderBtn = document.getElementById('openFolderBtn');
      const folderInput = document.getElementById('folderInput');
      const fileTreeEl = document.getElementById('fileTree');

      let handleMode = false;                // true when using File System Access API
      let fileHandleByPath = new Map();      // path -> FileSystemFileHandle  (handleMode)
      let fileBlobByPath = new Map();        // path -> File               (fallback mode)
      let rootDirHandle = null;              // keep folder handle for permission checks

      // Helper: verify/request read permission (should run within a user gesture)
      async function ensurePermission(handle, mode = 'read') {
        try {
          if (!handle || typeof handle.queryPermission !== 'function') return true;
          const opts = { mode };
          let p = await handle.queryPermission(opts);
          if (p === 'granted') return true;
          if (p === 'prompt') {
            p = await handle.requestPermission(opts);
            return p === 'granted';
          }
          return false; // denied
        } catch {
          return true;  // some browsers don’t support these methods; assume OK
        }
      }

      // Reopen hint wiring
      reopenBtn?.addEventListener('click', () => openFolderBtn.click());
      function showReopenHint(show) {
        if (reopenHint) reopenHint.style.display = show ? '' : 'none';
      }

      openFolderBtn.addEventListener('click', async () => {
        if ('showDirectoryPicker' in window) {
          try {
            if (!window.isSecureContext) {
              status.textContent = 'This feature requires a secure context (https or http://localhost).';
              showReopenHint(true);
              return;
            }
            rootDirHandle = await window.showDirectoryPicker({ mode: 'read' });

            const ok = await ensurePermission(rootDirHandle, 'read');
            if (!ok) {
              status.textContent = 'Permission to read this folder was not granted.';
              showReopenHint(true);
              return;
            }

            handleMode = true;
            status.textContent = 'Building directory tree…';
            fileHandleByPath.clear();
            fileBlobByPath.clear();

            const rootNode = await buildTreeFromDirectoryHandle(rootDirHandle, rootDirHandle.name);
            renderTree(rootNode, fileTreeEl);
            status.textContent = `Loaded folder: ${rootDirHandle.name}`;
            showReopenHint(false);
          } catch (e) {
            if (e && e.name !== 'AbortError') {
              console.error(e);
              status.textContent = 'Unable to open folder.';
              showReopenHint(true);
            }
          }
        } else {
          // Fallback to <input webkitdirectory>
          folderInput.click();
        }
      });

      folderInput.addEventListener('change', async (e) => {
        const files = Array.from(e.target.files || []);
        if (!files.length) return;
        handleMode = false;
        status.textContent = 'Building directory tree…';
        fileHandleByPath.clear();
        fileBlobByPath.clear();

        const rootName = commonRootFolderName(files);
        const rootNode = buildTreeFromFileList(files, rootName);
        renderTree(rootNode, fileTreeEl);
        status.textContent = `Loaded folder: ${rootName}`;
        showReopenHint(false);
      });

      // Build a directory tree using the File System Access API
      async function buildTreeFromDirectoryHandle(dirHandle, rootName) {
        const node = { name: rootName || dirHandle.name, kind: 'directory', children: [], path: '' };

        for await (const [name, entry] of dirHandle.entries()) {
          if (entry.kind === 'file') {
            if (!name.toLowerCase().endsWith('.md')) continue;
            const path = name; // root-level file
            fileHandleByPath.set(path, entry);
            node.children.push({ name, kind: 'file', path });
          } else if (entry.kind === 'directory') {
            const sub = await buildTreeFromDirectoryHandleRecursive(entry, name);
            node.children.push(sub);
          }
        }

        sortTree(node);
        return node;
      }

      async function buildTreeFromDirectoryHandleRecursive(dirHandle, basePath) {
        const node = { name: dirHandle.name, kind: 'directory', children: [], path: basePath };
        for await (const [name, entry] of dirHandle.entries()) {
          const entryPath = `${basePath}/${name}`;
          if (entry.kind === 'file') {
            if (!name.toLowerCase().endsWith('.md')) continue;
            fileHandleByPath.set(entryPath, entry);
            node.children.push({ name, kind: 'file', path: entryPath });
          } else {
            const sub = await buildTreeFromDirectoryHandleRecursive(entry, entryPath);
            node.children.push(sub);
          }
        }
        sortTree(node);
        return node;
      }

      // Build a directory tree from <input webkitdirectory> FileList
      function buildTreeFromFileList(files, rootName) {
        const root = { name: rootName || 'root', kind: 'directory', children: [], path: '' };
        const dirMap = new Map(); // path -> node
        dirMap.set('', root);

        for (const f of files) {
          if (!f.name.toLowerCase().endsWith('.md')) continue;

          const rel = f.webkitRelativePath || f.name; // ✅ correct extraction
          const parts = rel.split('/');

          // Map each directory segment
          let accPath = '';
          for (let i = 0; i < parts.length - 1; i++) {
            const p = parts[i];
            const next = accPath ? `${accPath}/${p}` : p;
            if (!dirMap.has(next)) {
              const parent = dirMap.get(accPath);
              const dirNode = { name: p, kind: 'directory', children: [], path: next };
              parent.children.push(dirNode);
              dirMap.set(next, dirNode);
            }
            accPath = next;
          }

          // Add the file node
          const filePath = rel;
          fileBlobByPath.set(filePath, f);
          const parent = dirMap.get(accPath);
          parent.children.push({ name: parts[parts.length - 1], kind: 'file', path: filePath });
        }

        sortTree(root);
        return root;
      }

      function renderTree(node, container) {
        container.innerHTML = '';
        const treeEl = document.createElement('div');
        treeEl.appendChild(renderNode(node));
        container.appendChild(treeEl);
      }

      function renderNode(node) {
        if (node.kind === 'file') {
          const btn = document.createElement('button');
          btn.className = 'file-btn';
          btn.type = 'button';
          btn.textContent = node.name;
          btn.title = node.path;
          btn.addEventListener('click', () => handleTreeFileClick(node.path));
          return btn;
        } else {
          const details = document.createElement('details');
          details.open = true;
          const summary = document.createElement('summary');
          summary.textContent = node.name;
          details.appendChild(summary);
          for (const child of node.children) {
            const childEl = renderNode(child);
            const wrapper = document.createElement('div');
            wrapper.appendChild(childEl);
            details.appendChild(wrapper);
          }
          return details;
        }
      }

      function sortTree(node) {
        if (!node.children) return;
        node.children.sort((a, b) => {
          if (a.kind !== b.kind) return a.kind === 'directory' ? -1 : 1;
          return a.name.localeCompare(b.name, undefined, { sensitivity: 'base' });
        });
        for (const c of node.children) if (c.kind === 'directory') sortTree(c);
      }

      function commonRootFolderName(files) {
        const paths = files.map(f => f.webkitRelativePath || f.name).filter(Boolean);
        if (!paths.length) return 'folder';
        const first = paths[0].split('/');
        let i = 0;
        for (; i < first.length - 1; i++) {
          const segment = first[i];
          if (!paths.every(p => p.split('/')[i] === segment)) break;
        }
        return (i > 0) ? first[0] : 'folder';
      }

      async function handleTreeFileClick(path) {
        try {
          // Re-check permission on the selected folder (covers children)
          if (handleMode && rootDirHandle) {
            const ok = await ensurePermission(rootDirHandle, 'read');
            if (!ok) {
              status.textContent = 'Folder permission was revoked. Please choose the folder again.';
              showReopenHint(true);
              return;
            }
          }

          let md = '';
          if (handleMode) {
            const handle = fileHandleByPath.get(path);
            if (!handle) {
              status.textContent = 'Could not resolve file handle.';
              return;
            }
            await ensurePermission(handle, 'read');
            const file = await handle.getFile(); // may throw NotReadableError
            md = await file.text();
          } else {
            const file = fileBlobByPath.get(path);
            if (!file) {
              status.textContent = 'Could not resolve file blob.';
              return;
            }
            md = await file.text();
          }

          // Load into left textarea and enable copy/download
          mdOut.value = md;
          mdOut.readOnly = false;   // allow editing if desired
          currentMd = md;
          statsMd.textContent = String(md.length);

          // Render Markdown -> HTML preview
          const html = renderMarkdownToHtml(md);
          htmlPreview.innerHTML = html;
          statsHtml.textContent = String(html.length);

          statsImg.textContent = '–'; // not applicable for plain MD
          copyBtn.disabled = false;
          downloadMdBtn.disabled = false;
          downloadAssetsBtn.disabled = true;

          status.textContent = `Loaded Markdown: ${path}`;
          showReopenHint(false);
          htmlPreview.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
        } catch (e) {
          console.error(e);
          if (e && e.name === 'NotReadableError') {
            status.textContent = 'Permission to read this file was revoked. Please choose the folder again.';
            showReopenHint(true);
          } else if (e && e.name === 'NotFoundError') {
            status.textContent = 'The file appears to have moved or been deleted.';
          } else {
            status.textContent = 'Failed to load selected Markdown file.';
          }
        }
      }

      // Prefer marked.js if available; otherwise a minimal fallback.
      function renderMarkdownToHtml(md) {
        if (window.marked && typeof window.marked.parse === 'function') {
          // For untrusted content, consider sanitizing with DOMPurify.
          return window.marked.parse(md, { mangle: false, headerIds: true });
        }
        // Tiny fallback: escape + a few common patterns (not fully spec-compliant)
        let safe = md
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;');

        // headings
        safe = safe.replace(/^(#{1,6})\s*(.+)$/gm, (_, h, t) => `<h${h.length}>${t}</h${h.length}>`);

        // horizontal rules
        safe = safe.replace(/^\s*[-*_]{3,}\s*$/gm, '<hr>');

        // bold/italic
        safe = safe.replace(/\*\*([\s\S]+?)\*\*/g, '<strong>$1</strong>');
        safe = safe.replace(/\*([\s\S]+?)\*/g, '<em>$1</em>');

        // code fence
        safe = safe.replace(/```([\s\S]*?)```/g, '<pre><code>$1</code></pre>');

        // inline code
        safe = safe.replace(/`([^`]+)`/g, '<code>$1</code>');

        // links [text](href "title")
        safe = safe.replace(/\[([^\]]+)\]\(([^)\s]+)(?:\s+"[^"]*")?\)/g,
     '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');

        // simple lists (unordered)
        safe = safe.replace(/^(?:\s*[-*+]\s+.+(?:\n|$))+?/gm, block => {
          const items = block.trim().split(/\n/).map(line =>
            line.replace(/^\s*[-*+]\s+(.+)$/, '<li>$1</li>')
          ).join('');
          return `<ul>${items}</ul>`;
        });
        
        return safe;
      }
      // ------------------ End directory tree code ------------------
    });
  </script>
</body>
</html>
